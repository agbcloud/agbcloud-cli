# AgbCloud CLI Test Package Distribution Pipeline
name: AgbCloud CLI Test Package Distribution

# Auto trigger conditions
triggers:
  push:
    branches:
      - master
      - main

# Global variables
variables:
  VERSION_PREFIX: dev

# Pipeline job definitions
jobs:
  # Unit tests
  unit-tests:
    name: Unit Tests
    runs-on: 2-8Gi
    timeout: 20m
    steps:
      - uses: checkout
      - uses: setup-env
        inputs:
          go-version: "1.23.2"
          go-mod-cache: true
          go-cache: false
      
      - id: install-test-dependencies
        name: Install Test Dependencies
        run: |
          echo "Installing test dependencies..."
          go mod download
          go mod tidy
      
      - id: run-unit-tests
        name: Run Unit Tests
        run: |
          echo "Running unit tests..."
          
          # Run unit tests with coverage
          if ! make test-unit; then
            echo "‚ùå Unit tests failed"
            exit 1
          fi
          echo "‚úÖ Unit tests passed"
      
      - id: generate-coverage
        name: Generate Coverage Report
        run: |
          echo "Generating coverage report..."
          if ! make test-coverage; then
            echo "‚ö†Ô∏è Coverage report generation failed, but continuing..."
          else
            echo "‚úÖ Coverage report generated successfully"
          fi
          
          # Display test summary
          echo ""
          echo "üìä Test Summary:"
          go test -v ./test/unit/... 2>/dev/null | grep -E "(PASS|FAIL|RUN)" | tail -10 || true

  # Build and deploy
  build-and-deploy:
    name: Build and Deploy
    runs-on: 4-16Gi
    timeout: 45m
    needs: [unit-tests]
    outputs:
      version: ${{steps.setup-build-vars.outputs.version}}
      timestamp: ${{steps.setup-build-vars.outputs.timestamp}}
    steps:
      - uses: checkout
      - uses: setup-env
        inputs:
          go-version: "1.23.2"
          go-mod-cache: true
          go-cache: false
      
      - id: setup-build-vars
        name: Setup Build Variables
        run: |
          echo "Setting up build variables..."
          export VERSION_PREFIX="${{vars.VERSION_PREFIX}}"
          export TIMESTAMP=$(TZ='Asia/Shanghai' date "+%Y%m%d-%H%M")
          export VERSION="${VERSION_PREFIX:-dev}-$TIMESTAMP"
          export GIT_COMMIT=$(git rev-parse --short HEAD)
          export BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          
          echo "Build variables:"
          echo "VERSION_PREFIX=$VERSION_PREFIX"
          echo "TIMESTAMP=$TIMESTAMP"
          echo "VERSION=$VERSION"
          echo "GIT_COMMIT=$GIT_COMMIT"
          echo "BUILD_DATE=$BUILD_DATE"
          
          # Save to workspace files for sharing across steps in same job
          echo "VERSION=$VERSION" > $AONE_CI_WORKSPACE/BUILD_VERSION
          echo "TIMESTAMP=$TIMESTAMP" > $AONE_CI_WORKSPACE/BUILD_TIMESTAMP
          echo "GIT_COMMIT=$GIT_COMMIT" > $AONE_CI_WORKSPACE/BUILD_GIT_COMMIT
          echo "BUILD_DATE=$BUILD_DATE" > $AONE_CI_WORKSPACE/BUILD_DATE
          
          # Also try environment variables
          echo "VERSION=$VERSION" >> $AONE_CI_ENV
          echo "TIMESTAMP=$TIMESTAMP" >> $AONE_CI_ENV
          echo "GIT_COMMIT=$GIT_COMMIT" >> $AONE_CI_ENV
          echo "BUILD_DATE=$BUILD_DATE" >> $AONE_CI_ENV
          
          # Output for job-level sharing
          echo "$VERSION" > ${{outputs.version.path}}
          echo "$TIMESTAMP" > ${{outputs.timestamp.path}}
          
          echo "‚úÖ Build variables saved to workspace and outputs"
      
      - id: build-binaries
        name: Build Multi-platform Binaries
        run: |
          echo "Building binaries for all platforms..."
          
          # Load variables from environment or workspace files
          if [ -z "$VERSION" ] && [ -f "$AONE_CI_WORKSPACE/BUILD_VERSION" ]; then
            export VERSION=$(cat $AONE_CI_WORKSPACE/BUILD_VERSION)
          fi
          if [ -z "$GIT_COMMIT" ] && [ -f "$AONE_CI_WORKSPACE/BUILD_GIT_COMMIT" ]; then
            export GIT_COMMIT=$(cat $AONE_CI_WORKSPACE/BUILD_GIT_COMMIT)
          fi
          echo "Build version: $VERSION"
          echo "Git commit: $GIT_COMMIT"
          make build-all
          ls -la bin/

      - id: create-packages
        name: Create Packages
        run: |
          echo "Creating packages..."
          
          # Load variables from environment or workspace files
          if [ -z "$VERSION" ] && [ -f "$AONE_CI_WORKSPACE/BUILD_VERSION" ]; then
            export VERSION=$(cat $AONE_CI_WORKSPACE/BUILD_VERSION)
          fi
          mkdir -p packages
          
          for binary in bin/*; do
            if [[ -f "$binary" ]]; then
              filename=$(basename "$binary")
              platform_arch=${filename#${{vars.BINARY_NAME}}-}
              # Remove .exe extension from platform_arch for consistent naming
              platform_arch_clean=$(echo "$platform_arch" | sed 's/\.exe$//')
              
              # Create packages based on platform
              temp_dir=$(mktemp -d)
              cp "$binary" "$temp_dir/${{vars.BINARY_NAME}}"
              
              if [[ "$platform_arch_clean" == windows-* ]]; then
                # For Windows, create .zip packages (more Windows-friendly)
                # Ensure the binary has .exe extension in the zip
                mv "$temp_dir/${{vars.BINARY_NAME}}" "$temp_dir/${{vars.BINARY_NAME}}.exe"
                (cd "$temp_dir" && zip -q "../packages/${{vars.BINARY_NAME}}-$VERSION-$platform_arch_clean.zip" "${{vars.BINARY_NAME}}.exe")
                sha256sum "packages/${{vars.BINARY_NAME}}-$VERSION-$platform_arch_clean.zip" > "packages/${{vars.BINARY_NAME}}-$VERSION-$platform_arch_clean.zip.sha256"
                echo "‚úì Created Windows package: ${{vars.BINARY_NAME}}-$VERSION-$platform_arch_clean.zip"
                
                # Also create direct .exe files for convenience
                target_name="${{vars.BINARY_NAME}}-$VERSION-$platform_arch_clean.exe"
                cp "$binary" "packages/$target_name"
                sha256sum "packages/$target_name" > "packages/$target_name.sha256"
                echo "‚úì Created Windows executable: $target_name"
              else
                # For non-Windows platforms, continue using .tar.gz
                tar -czf "packages/${{vars.BINARY_NAME}}-$VERSION-$platform_arch_clean.tar.gz" -C "$temp_dir" ${{vars.BINARY_NAME}}
                sha256sum "packages/${{vars.BINARY_NAME}}-$VERSION-$platform_arch_clean.tar.gz" > "packages/${{vars.BINARY_NAME}}-$VERSION-$platform_arch_clean.tar.gz.sha256"
                echo "‚úì Created package: ${{vars.BINARY_NAME}}-$VERSION-$platform_arch_clean.tar.gz"
              fi
              
              rm -rf "$temp_dir"
            fi
          done
          
          ls -la packages/
          
          # Verify Windows executables were created
          echo ""
          echo "üîç Verifying Windows executables:"
          for exe in packages/*windows*.exe; do
            if [[ -f "$exe" ]]; then
              echo "‚úì Found: $(basename "$exe")"
              # Verify it's a valid PE executable
              if file "$exe" | grep -q "PE32"; then
                echo "  ‚úì Valid Windows executable"
              else
                echo "  ‚ö† Warning: May not be a valid Windows executable"
              fi
              # Check file size
              size=$(stat -c%s "$exe" 2>/dev/null || stat -f%z "$exe" 2>/dev/null || echo "unknown")
              echo "  üìè Size: $size bytes"
            fi
          done
          
          # Also verify zip packages for Windows
          echo ""
          echo "üîç Verifying Windows zip packages:"
          for pkg in packages/*windows*.zip; do
            if [[ -f "$pkg" ]]; then
              echo "‚úì Found: $(basename "$pkg")"
              # Verify it's a valid zip file
              if unzip -t "$pkg" >/dev/null 2>&1; then
                echo "  ‚úì Valid zip archive"
              else
                echo "  ‚ö† Warning: May not be a valid zip archive"
              fi
              # Check file size
              size=$(stat -c%s "$pkg" 2>/dev/null || stat -f%z "$pkg" 2>/dev/null || echo "unknown")
              echo "  üìè Size: $size bytes"
            fi
          done

      - id: create-server-files
        name: Create Server Files
        run: |
          echo "Creating server files..."
          
          # Load variables from environment or workspace files
          if [ -z "$VERSION" ] && [ -f "$AONE_CI_WORKSPACE/BUILD_VERSION" ]; then
            export VERSION=$(cat $AONE_CI_WORKSPACE/BUILD_VERSION)
          fi
          
          # Make the script executable and run it
          chmod +x scripts/generate-server-files.sh
          ./scripts/generate-server-files.sh
          
          # Verify critical server files were created
          echo ""
          echo "üîç Verifying server files:"
          if [[ -f "server-files/install.ps1" ]]; then
            echo "‚úì PowerShell installer script created"
            echo "  Size: $(wc -c < server-files/install.ps1) bytes"
          else
            echo "‚ùå PowerShell installer script missing!"
            exit 1
          fi
          
          if [[ -f "server-files/latest.json" ]]; then
            echo "‚úì Version API file created"
            echo "  Content preview:"
            head -5 server-files/latest.json | sed 's/^/    /'
          else
            echo "‚ùå Version API file missing!"
            exit 1
          fi
          
          echo "‚úÖ Server files created successfully"

      - id: upload-to-oss
        name: Upload to OSS
        run: |
          echo "Uploading packages to OSS..."
          
          # Load variables from environment or workspace files
          if [ -z "$VERSION" ] && [ -f "$AONE_CI_WORKSPACE/BUILD_VERSION" ]; then
            export VERSION=$(cat $AONE_CI_WORKSPACE/BUILD_VERSION)
          fi
                    
          # Set OSS configuration variables
          export OSS_BUCKET="${{vars.OSS_BUCKET}}"
          export OSS_ENDPOINT="${{vars.OSS_ENDPOINT}}"
          
          # Set OSS credentials
          export OSS_ACCESS_KEY_ID="${{secrets.OSS_ACCESS_KEY_ID}}"
          export OSS_ACCESS_KEY_SECRET="${{secrets.OSS_ACCESS_KEY_SECRET}}"
          
          # Debug info - check credential length and prefix (without leaking full credentials)
          echo "=== OSS Credentials Debug Info ==="
          echo "OSS_ACCESS_KEY_ID length: ${#OSS_ACCESS_KEY_ID}"
          echo "OSS_ACCESS_KEY_SECRET length: ${#OSS_ACCESS_KEY_SECRET}"
          echo "OSS_ACCESS_KEY_ID prefix: ${OSS_ACCESS_KEY_ID:0:8}..."
          echo "OSS_ACCESS_KEY_SECRET prefix: ${OSS_ACCESS_KEY_SECRET:0:8}..."
          echo "OSS_ENDPOINT: $OSS_ENDPOINT"
          echo "OSS_BUCKET: $OSS_BUCKET"
          
          # Check if credentials are set
          if [[ -z "$OSS_ACCESS_KEY_ID" ]] || [[ -z "$OSS_ACCESS_KEY_SECRET" ]]; then
            echo "Error: OSS credentials not set in secrets"
            echo "OSS_ACCESS_KEY_ID is empty: $([ -z "$OSS_ACCESS_KEY_ID" ] && echo 'YES' || echo 'NO')"
            echo "OSS_ACCESS_KEY_SECRET is empty: $([ -z "$OSS_ACCESS_KEY_SECRET" ] && echo 'YES' || echo 'NO')"
            exit 1
          fi
          
          # Network connectivity test
          echo "=== Network Connectivity Test ==="
          echo "Testing connectivity to OSS endpoint..."
          if ping -c 3 $OSS_ENDPOINT; then
            echo "‚úì Ping to OSS endpoint successful"
          else
            echo "‚ö† Ping to OSS endpoint failed"
          fi
          
          if curl -I --connect-timeout 10 https://$OSS_ENDPOINT; then
            echo "‚úì HTTP connection to OSS endpoint successful"
          else
            echo "‚ö† HTTP connection to OSS endpoint failed"
          fi
          
          # Install ossutil
          if ! command -v ossutil >/dev/null 2>&1; then
            echo "Installing ossutil..."
            curl -L "https://gosspublic.alicdn.com/ossutil/1.7.19/ossutil-v1.7.19-linux-amd64.zip" -o ossutil.zip
            unzip -q ossutil.zip
            
            # Find correct ossutil binary
            OSSUTIL_BINARY=$(find . -name "ossutil*" -type f | head -1)
            if [[ -z "$OSSUTIL_BINARY" ]]; then
              echo "Error: Failed to find ossutil binary after extraction"
              exit 1
            fi
            
            chmod +x "$OSSUTIL_BINARY"
            mv "$OSSUTIL_BINARY" /usr/local/bin/ossutil
            rm -f ossutil.zip
            rm -rf ossutil*/
            
            echo "‚úì ossutil installed successfully"
          else
            echo "‚úì ossutil already installed"
          fi
          
          # Configure and upload
          echo "=== OSS Configuration ==="
          echo "Configuring ossutil with verbose output..."
          
          # Configure ossutil with verbose mode
          if ossutil config --endpoint="${{vars.OSS_ENDPOINT}}" --access-key-id="$OSS_ACCESS_KEY_ID" --access-key-secret="$OSS_ACCESS_KEY_SECRET"; then
            echo "‚úì ossutil configuration successful"
          else
            echo "‚úó ossutil configuration failed"
            exit 1
          fi
          
          # Verify configuration - with verbose mode
          echo "=== OSS Connection Test ==="
          echo "Testing connection to bucket: ${{vars.OSS_BUCKET}}"
          
          if ossutil ls oss://${{vars.OSS_BUCKET}}/; then
            echo "‚úì Successfully connected to OSS bucket: ${{vars.OSS_BUCKET}}"
          else
            echo "‚úó Failed to connect to OSS bucket: ${{vars.OSS_BUCKET}}"
            echo "Attempting to diagnose the issue..."
            
            # Try more detailed diagnostics
            echo "Testing basic OSS connectivity..."
            ossutil ls oss:// || true
            
            echo "Testing bucket existence with stat command..."
            ossutil stat oss://${{vars.OSS_BUCKET}}/ || true
            
            echo "Checking ossutil configuration..."
            ossutil config || true
            
            exit 1
          fi
          
          echo "OSS configuration successful, uploading packages..."
          
          # Upload binary packages (including .exe and .zip files for Windows)
          for package in packages/*.tar.gz packages/*.zip packages/*.exe packages/*.sha256; do
            if [[ -f "$package" ]]; then
              filename=$(basename "$package")
              echo "Uploading $filename to version directory $VERSION..."
              
              if ossutil cp "$package" "oss://$OSS_BUCKET/${{vars.BINARY_NAME}}/releases/$VERSION/$filename" --force; then
                if ossutil set-acl "oss://$OSS_BUCKET/${{vars.BINARY_NAME}}/releases/$VERSION/$filename" public-read; then
                  echo "‚úì Uploaded and set public: $filename"
                else
                  echo "‚ö† Uploaded but failed to set ACL: $filename"
                fi
              else
                echo "‚úó Failed to upload: $filename"
                exit 1
              fi
            fi
          done
          
          # Upload server files (version info, etc.)
          for serverfile in server-files/*; do
            if [[ -f "$serverfile" ]]; then
              filename=$(basename "$serverfile")
              echo "Uploading server file: $filename to version directory $VERSION..."
              
              # Upload to version-specific directory
              if ossutil cp "$serverfile" "oss://$OSS_BUCKET/${{vars.BINARY_NAME}}/releases/$VERSION/$filename" --force; then
                if ossutil set-acl "oss://$OSS_BUCKET/${{vars.BINARY_NAME}}/releases/$VERSION/$filename" public-read; then
                  echo "‚úì Uploaded and set public: $filename"
                else
                  echo "‚ö† Uploaded but failed to set ACL: $filename"
                fi
              else
                echo "‚úó Failed to upload server file: $filename"
                exit 1
              fi
              
              # Also upload latest.json to root for backward compatibility
              if [[ "$filename" == "latest.json" ]]; then
                echo "Also uploading latest.json to root for backward compatibility..."
                if ossutil cp "$serverfile" "oss://$OSS_BUCKET/latest.json" --force; then
                  if ossutil set-acl "oss://$OSS_BUCKET/latest.json" public-read; then
                    echo "‚úì Uploaded latest.json to root"
                  else
                    echo "‚ö† Uploaded latest.json to root but failed to set ACL"
                  fi
                else
                  echo "‚ö† Failed to upload latest.json to root"
                fi
              fi
            fi
          done

      - id: send-notification
        name: Send Notification
        run: |
          # Try to load from environment variables first, then from workspace files as fallback
          if [ -z "$VERSION" ] && [ -f "$AONE_CI_WORKSPACE/BUILD_VERSION" ]; then
            export VERSION=$(cat $AONE_CI_WORKSPACE/BUILD_VERSION)
          fi
          if [ -z "$TIMESTAMP" ] && [ -f "$AONE_CI_WORKSPACE/BUILD_TIMESTAMP" ]; then
            export TIMESTAMP=$(cat $AONE_CI_WORKSPACE/BUILD_TIMESTAMP)
          fi
          
          echo "Debug: VERSION=$VERSION"
          echo "Debug: TIMESTAMP=$TIMESTAMP"
          
          echo "üéâ ${{vars.BINARY_NAME}} CLI Multi-platform Test Package Build Complete!"
          echo ""
          echo "üì¶ Version: $VERSION"
          echo "üïí Timestamp: $TIMESTAMP"
          echo "üìù Git Commit: $(git rev-parse --short HEAD)"
          echo "‚úÖ Test Status: Unit tests passed ‚úì"
          echo "üåç Supported Platforms: macOS, Linux, Windows"
          echo ""
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "üíª Windows Users"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo ""
          echo "üì¶ Direct Download:"
          echo "   ‚Ä¢ Windows x64:   https://${{vars.OSS_BUCKET}}.${{vars.OSS_ENDPOINT}}/${{vars.BINARY_NAME}}/releases/$VERSION/${{vars.BINARY_NAME}}-$VERSION-windows-amd64.exe"
          echo "   ‚Ä¢ Windows ARM64: https://${{vars.OSS_BUCKET}}.${{vars.OSS_ENDPOINT}}/${{vars.BINARY_NAME}}/releases/$VERSION/${{vars.BINARY_NAME}}-$VERSION-windows-arm64.exe"
          echo ""
          echo "üì¶ Archive Download:"
          echo "   ‚Ä¢ Windows x64:   https://${{vars.OSS_BUCKET}}.${{vars.OSS_ENDPOINT}}/${{vars.BINARY_NAME}}/releases/$VERSION/${{vars.BINARY_NAME}}-$VERSION-windows-amd64.zip"
          echo "   ‚Ä¢ Windows ARM64: https://${{vars.OSS_BUCKET}}.${{vars.OSS_ENDPOINT}}/${{vars.BINARY_NAME}}/releases/$VERSION/${{vars.BINARY_NAME}}-$VERSION-windows-arm64.zip"
          echo ""
          echo "üìã Usage Instructions:"
          echo "   1. Download the executable for your architecture"
          echo "   2. Rename the file to ${{vars.BINARY_NAME}}.exe"
          echo "   3. Move the file to a directory in your PATH environment variable"
          echo "   4. Run in command line: ${{vars.BINARY_NAME}} version"
          echo ""
          echo "üí° Tips:"
          echo "   ‚Ä¢ Recommended to place executable in %USERPROFILE%\\bin\\ directory"
          echo "   ‚Ä¢ Add that directory to your PATH environment variable"
          echo ""
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "üçéüêß macOS / Linux Users"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo ""
          echo "üì¶ Download Links:"
          echo "   ‚Ä¢ macOS Intel:        https://${{vars.OSS_BUCKET}}.${{vars.OSS_ENDPOINT}}/${{vars.BINARY_NAME}}/releases/$VERSION/${{vars.BINARY_NAME}}-$VERSION-darwin-amd64.tar.gz"
          echo "   ‚Ä¢ macOS Apple Silicon: https://${{vars.OSS_BUCKET}}.${{vars.OSS_ENDPOINT}}/${{vars.BINARY_NAME}}/releases/$VERSION/${{vars.BINARY_NAME}}-$VERSION-darwin-arm64.tar.gz"
          echo "   ‚Ä¢ Linux x64:          https://${{vars.OSS_BUCKET}}.${{vars.OSS_ENDPOINT}}/${{vars.BINARY_NAME}}/releases/$VERSION/${{vars.BINARY_NAME}}-$VERSION-linux-amd64.tar.gz"
          echo "   ‚Ä¢ Linux ARM64:        https://${{vars.OSS_BUCKET}}.${{vars.OSS_ENDPOINT}}/${{vars.BINARY_NAME}}/releases/$VERSION/${{vars.BINARY_NAME}}-$VERSION-linux-arm64.tar.gz"
          echo ""
          echo "üöÄ Quick Install (macOS/Linux):"
          echo "   # macOS Intel"
          echo "   curl -L https://${{vars.OSS_BUCKET}}.${{vars.OSS_ENDPOINT}}/${{vars.BINARY_NAME}}/releases/$VERSION/${{vars.BINARY_NAME}}-$VERSION-darwin-amd64.tar.gz | tar -xz"
          echo "   sudo mv ${{vars.BINARY_NAME}} /usr/local/bin/"
          echo "   "
          echo "   # macOS Apple Silicon"
          echo "   curl -L https://${{vars.OSS_BUCKET}}.${{vars.OSS_ENDPOINT}}/${{vars.BINARY_NAME}}/releases/$VERSION/${{vars.BINARY_NAME}}-$VERSION-darwin-arm64.tar.gz | tar -xz"
          echo "   sudo mv ${{vars.BINARY_NAME}} /usr/local/bin/"
          echo "   "
          echo "   # Linux AMD64"
          echo "   curl -L https://${{vars.OSS_BUCKET}}.${{vars.OSS_ENDPOINT}}/${{vars.BINARY_NAME}}/releases/$VERSION/${{vars.BINARY_NAME}}-$VERSION-linux-amd64.tar.gz | tar -xz"
          echo "   sudo mv ${{vars.BINARY_NAME}} /usr/local/bin/"
          echo "   "
          echo "   # Linux ARM64"
          echo "   curl -L https://${{vars.OSS_BUCKET}}.${{vars.OSS_ENDPOINT}}/${{vars.BINARY_NAME}}/releases/$VERSION/${{vars.BINARY_NAME}}-$VERSION-linux-arm64.tar.gz | tar -xz"
          echo "   sudo mv ${{vars.BINARY_NAME}} /usr/local/bin/"
          echo ""
          echo "üìã Usage Instructions:"
          echo "   ${{vars.BINARY_NAME}} version        # Check version"
          echo "   ${{vars.BINARY_NAME}} --help         # Show help"
          echo "   ${{vars.BINARY_NAME}} login          # Login to cloud platform"
          echo ""
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "üìö More Information"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "‚Ä¢ Version API: https://${{vars.OSS_BUCKET}}.${{vars.OSS_ENDPOINT}}/latest.json"
          echo "‚Ä¢ Documentation: https://docs.agbcloud.com"
          echo "‚Ä¢ Source Code: https://github.com/your-org/${{vars.BINARY_NAME}}-cli"
          echo "‚Ä¢ Issue Reports: https://github.com/your-org/${{vars.BINARY_NAME}}-cli/issues"